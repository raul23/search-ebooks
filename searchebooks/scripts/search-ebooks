#!/usr/bin/env python
import argparse
import os
import re
import time
from pathlib import Path

import searchebooks
from pyebooktools.convert_to_txt import convert
from pyebooktools.configs import default_config
from pyebooktools.lib import BOLD, GREEN, NC, RED, YELLOW

DEFAULT_EBOOK_FORMATS = ['djvu', 'epub', 'html', 'pdf', 'txt']
CACHE_FOLDER = os.path.expanduser('~/.search_ebooks')
CACHE_SIZE_LIMIT = default_config.cache_size_limit
EVICTION_POLICY = default_config.eviction_policy
USE_CACHE = default_config.use_cache


def get_files(input_data):
    # NOTE: only pdf files supported
    # TODO: important, use get_mime_type?
    files = []
    input_data = Path(input_data)
    if input_data.is_file():
        ext = input_data.suffix.split('.')[-1]
        if ext in DEFAULT_EBOOK_FORMATS:
            files = [input_data]
        else:
            # TODO: important, logger
            pass
    else:
        # TODO: important, use get_mime_type for each file found?
        # you can have a pdf file with the wrong ext?
        for fp in input_data.rglob('*'):
            ext = fp.suffix.split('.')[-1]
            if ext in DEFAULT_EBOOK_FORMATS:
                files.append(fp)
        # TODO: important sort within glob?
        # logger.debug("Files sorted {}".format("in desc" if reverse else "in asc"))
        # files.sort(key=lambda x: x.name, reverse=self.reverse)
    return files


def check_formats():
    class CheckFromats(argparse.Action):
        def __call__(self, parser, args, values, option_string=None):
            for i, v in enumerate(values):
                if v.startswith('.'):
                    v = v[1:]
                    values[i] = v
                if v not in DEFAULT_EBOOK_FORMATS:
                    msg = f'argument "{self.dest}" doesn\'t support {v}. Only ' \
                          'the following ebook formats are supported: ' \
                          f'{DEFAULT_EBOOK_FORMATS}'
                    raise argparse.ArgumentTypeError(msg)
            setattr(args, self.dest, values)
    return CheckFromats


def setup_argparser():
    # Setup the parser
    parser = argparse.ArgumentParser(
        description='Search through content and metadata of ebooks.\n\n'
                    'IMPORTANT: if an argument has spaces, enclose it in '
                    'quotation marks, e.g. "Book title with spaces"',
        # ArgumentDefaultsHelpFormatter
        # HelpFormatter
        # RawDescriptionHelpFormatter
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-v', '--version', action='version',
        version=f'%(prog)s v{searchebooks.__version__}')
    parser.add_argument(
        '-q', '--quiet', action='store_true',
        help='Enable quiet mode, i.e. nothing will be printed.')
    parser.add_argument(
        '--verbose', action='store_true',
        help='Print various debugging information, e.g. print traceback '
             'when there is an exception.')
    parser.add_argument(
        '-c', '--case-sensitive', action='store_true',
        help='Case sensitive')
    # =====
    # Cache
    # =====
    cache_group = parser.add_argument_group(title='Cache options')
    cache_group.add_argument(
        '--use-cache', action='store_true', help='Use cache')
    cache_group.add_argument(
        '--cache-folder', default=CACHE_FOLDER, help='Cache folder')
    cache_group.add_argument(
        '--ep', '--eviction-policy', metavar='POLICY', dest='eviction_policy',
        choices=['least-recently-stored', '=least-recently-used',
                 'least-frequently-used', 'none'], default=EVICTION_POLICY,
        help='Eviction policy where none="never evict keys".')
    cache_group.add_argument(
        '--csl', '--cache-size-limit', dest='cache_size_limit',
        default=CACHE_SIZE_LIMIT, type=int, help='Size limit in gigabytes (GB)')
    # ===========
    # Search text
    # ===========
    search_text_group = parser.add_argument_group(
        title='Search through text of ebooks')
    search_text_group.add_argument(
        '--query', dest='search_query', metavar='QUERY', required=True,
        help='Search query')
    search_text_group.add_argument(
        '-f', '--ebook-formats', metavar='FORMAT', nargs='+',
        default=DEFAULT_EBOOK_FORMATS, action=check_formats(),
        help='Ebook formats')
    search_text_group.add_argument(
        '--dsm', '--djvu-search-method', metavar='METHOD',
        dest='djvu_search_method', choices=['djvutxt', 'calibre'],
        default='djvutxt', help='Search method for djvu files')
    search_text_group.add_argument(
        '--msm', '--msword-search-method', metavar='METHOD',
        dest='msword_search_method', choices=['catdoc', 'textutil', 'calibre'],
        default='textutil', help='Search method for djvu files')
    search_text_group.add_argument(
        '--esm', '--epub-search-method', metavar='METHOD',
        dest='epub_search_method', choices=['zipgrep', 'calibre'],
        default='zipgrep', help='Search method for epub files')
    search_text_group.add_argument(
        '--psm', '--pdf-search-method', metavar='METHOD',
        dest='pdf_search_method', choices=['pdftotext', 'calibre'],
        default='pdftotext', help='Search method for pdf files')
    # ===============
    # Search metadata
    # ===============
    search_metadata_group = parser.add_argument_group(
        title='Search through metadata of ebooks')
    search_metadata_group.add_argument(
        '-a', '--authors', help='Authors')
    search_metadata_group.add_argument(
        '-k', '--book-producer', help='Book producer')
    search_metadata_group.add_argument(
        '--category', help='Category')
    search_metadata_group.add_argument(
        '--comments', help='Comments')
    search_metadata_group.add_argument(
        '-d', '--date', help='Published date')
    search_metadata_group.add_argument(
        '--identifiers', help='Identifiers')
    search_metadata_group.add_argument(
        '-i', '--isbn', help='ISBN')
    search_metadata_group.add_argument(
        '-l', '--language', help='Language')
    search_metadata_group.add_argument(
        '-p', '--publisher', help='Publisher')
    search_metadata_group.add_argument(
        '--rating', help='Rating')
    search_metadata_group.add_argument(
        '-s', '--series', help='Series')
    search_metadata_group.add_argument(
        '--tags', help='Tags')
    search_metadata_group.add_argument(
        '-t', '--title', help='Title')
    # ==============
    # Input argument
    # ==============
    input_group = parser.add_argument_group(title='Input argument')
    input_group.add_argument(
        'input_data',
        help='Can either be the path to an ebook or a folder containing ebooks')
    return parser


def main():
    parser = setup_argparser()
    args = parser.parse_args()
    # TODO: check if can be done before
    args.cache_size_limit *= 10**9
    files = get_files(args.input_data)
    search_results = []
    num_results = 0
    total_seconds = 0
    window_length = 200
    import ipdb
    for fp in files:
        if fp.suffix.split('.')[-1] not in args.ebook_formats:
            continue
        start_time = time.time()
        text = convert(fp, **args.__dict__)
        if text == 1:
            continue
        if args.case_sensitive:
            flags = re.MULTILINE | re.IGNORECASE
        else:
            flags = re.MULTILINE
        matches = re.finditer(args.search_query, text, flags)
        search_result = {'filename': fp.name, 'folder_path': fp.parent,
                         'file_path': fp, 'matches': []}
        for match in matches:
            num_results += 1
            start, end = match.span()
            length = end - start
            if start < window_length/2:
                subtext = text[start - 0:int(start + length + window_length/2)]
            else:
                subtext = text[int(start - window_length / 2):int(start + length + window_length / 2)]
            subtext = re.sub(f"({args.search_query})", f"{GREEN}{BOLD}\\1{NC}",
                             subtext, flags=flags)
            # TODO: important, use trans
            subtext = subtext.replace('\n', ' ').replace('\x0cix', '').strip()
            # TODO: important, uncomment for interactive
            # search_result['matches'].append(subtext)
        search_results.append(search_result)
        total_seconds += time.time() - start_time
    search_results = sorted(search_results, key=lambda k: len(k['matches']),
                            reverse=True)
    print(f'{YELLOW}Total of {num_results} matches ({round(total_seconds, 3)} seconds){NC}\n')
    for i, result in enumerate(search_results, start=1):
        print(f"{i}.\t{result['filename']}\n\tFolder path: {result['folder_path']}"
              f"\n\tNumber of matches: {len(result['matches'])}\n")
    # ipdb.set_trace()
    return 0


if __name__ == '__main__':
    # search-ebooks ~/test/_search_ebooks/search_text/... --use-cache
    retcode = main()
