#!/usr/bin/env python
import argparse
import re
from pathlib import Path

import searchebooks
from pyebooktools.convert_to_txt import convert
from pyebooktools.configs import default_config

DEFAULT_EBOOK_FORMATS = ['djvu', 'epub', 'html', 'pdf', 'txt']
CACHE_FOLDER = default_config.cache_folder
CACHE_SIZE_LIMIT = default_config.cache_size_limit
EVICTION_POLICY = default_config.eviction_policy
USE_CACHE = default_config.use_cache


def get_files(input_data):
    # NOTE: only pdf files supported
    # TODO: important, use get_mime_type?
    files = []
    input_data = Path(input_data)
    if input_data.is_file():
        ext = input_data.suffix.split('.')[-1]
        if ext in DEFAULT_EBOOK_FORMATS:
            files = [input_data]
        else:
            # TODO: important, logger
            pass
    else:
        # TODO: important, use get_mime_type for each file found?
        # you can have a pdf file with the wrong ext?
        for fp in input_data.rglob('*'):
            ext = fp.suffix.split('.')[-1]
            if ext in DEFAULT_EBOOK_FORMATS:
                files.append(fp)
        # TODO: important sort within glob?
        # logger.debug("Files sorted {}".format("in desc" if reverse else "in asc"))
        # files.sort(key=lambda x: x.name, reverse=self.reverse)
    return files


def check_formats():
    class CheckFromats(argparse.Action):
        def __call__(self, parser, args, values, option_string=None):
            for i, v in enumerate(values):
                if v.startswith('.'):
                    v = v[1:]
                    values[i] = v
                if v not in DEFAULT_EBOOK_FORMATS:
                    msg = f'argument "{self.dest}" doesn\'t support {v}. Only ' \
                          'the following ebook formats are supported: ' \
                          f'{DEFAULT_EBOOK_FORMATS}'
                    raise argparse.ArgumentTypeError(msg)
            setattr(args, self.dest, values)
    return CheckFromats


def setup_argparser():
    # Setup the parser
    parser = argparse.ArgumentParser(
        description='Search through content and metadata of ebooks.\n\n'
                    'IMPORTANT: if an argument has spaces, enclose it in '
                    'quotation marks, e.g. "Book title with spaces"',
        # ArgumentDefaultsHelpFormatter
        # HelpFormatter
        # RawDescriptionHelpFormatter
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-v', '--version', action='version',
        version=f'%(prog)s v{searchebooks.__version__}')
    parser.add_argument(
        '-q', '--quiet', action='store_true',
        help='Enable quiet mode, i.e. nothing will be printed.')
    parser.add_argument(
        '--verbose', action='store_true',
        help='Print various debugging information, e.g. print traceback '
             'when there is an exception.')
    parser.add_argument(
        '-c', '--case-sensitive', action='store_true',
        help='Case sensitive')
    parser.add_argument(
        '-r', '--regex', action='store_true',
        help='Regex')
    # =====
    # Cache
    # =====
    cache_group = parser.add_argument_group(title='Cache options')
    cache_group.add_argument(
        '--use-cache', action='store_true', help='Use cache')
    cache_group.add_argument(
        '--cache-folder', default=CACHE_FOLDER, help='Cache folder')
    cache_group.add_argument(
        '--ep', '--eviction-policy', metavar='POLICY',
        choices=['lrs', 'lrs', 'lfu', 'none'], default=EVICTION_POLICY,
        help='Eviction policy where lrs=least-recently-stored, '
             'lrs=least-recently-used, lfu=least-frequently-used, and '
             'none="never evict keys"')
    cache_group.add_argument(
        '--csl', '--cache-size-limit', default=CACHE_SIZE_LIMIT, type=int,
        help='Size limit in gigabytes (GB)')
    # ===========
    # Search text
    # ===========
    search_text_group = parser.add_argument_group(
        title='Search through text of ebooks')
    search_text_group.add_argument(
        '--query', dest='search_query', metavar='QUERY', required=True,
        help='Search query')
    search_text_group.add_argument(
        '-f', '--ebook-formats', metavar='FORMAT', nargs='+',
        default=DEFAULT_EBOOK_FORMATS, action=check_formats(),
        help='Ebook formats')
    search_text_group.add_argument(
        '--dsm', '--djvu-search-method', metavar='METHOD',
        choices=['djvutxt', 'calibre'], default='djvutxt',
        help='Search method for djvu files')
    search_text_group.add_argument(
        '--msm', '--msword-search-method', metavar='METHOD',
        choices=['catdoc', 'textutil', 'calibre'], default='textutil',
        help='Search method for djvu files')
    search_text_group.add_argument(
        '--esm', '--epub-search-method', metavar='METHOD',
        choices=['zipgrep', 'calibre'], default='zipgrep',
        help='Search method for epub files')
    search_text_group.add_argument(
        '--psm', '--pdf-search-method', metavar='METHOD',
        choices=['pdftotext', 'calibre'], default='pdftotext',
        help='Search method for pdf files')
    # ===============
    # Search metadata
    # ===============
    search_metadata_group = parser.add_argument_group(
        title='Search through metadata of ebooks')
    search_metadata_group.add_argument(
        '-a', '--authors', help='Authors')
    search_metadata_group.add_argument(
        '-k', '--book-producer', help='Book producer')
    search_metadata_group.add_argument(
        '--category', help='Category')
    search_metadata_group.add_argument(
        '--comments', help='Comments')
    search_metadata_group.add_argument(
        '-d', '--date', help='Published date')
    search_metadata_group.add_argument(
        '--identifiers', help='Identifiers')
    search_metadata_group.add_argument(
        '-i', '--isbn', help='ISBN')
    search_metadata_group.add_argument(
        '-l', '--language', help='Language')
    search_metadata_group.add_argument(
        '-p', '--publisher', help='Publisher')
    search_metadata_group.add_argument(
        '--rating', help='Rating')
    search_metadata_group.add_argument(
        '-s', '--series', help='Series')
    search_metadata_group.add_argument(
        '--tags', help='Tags')
    search_metadata_group.add_argument(
        '-t', '--title', help='Title')
    # ==============
    # Input argument
    # ==============
    input_group = parser.add_argument_group(title='Input argument')
    input_group.add_argument(
        'input_data',
        help='Can either be the path to an ebook or a folder containing ebooks')
    return parser


def main():
    parser = setup_argparser()
    args = parser.parse_args()
    files = get_files(args.input_data)
    import ipdb
    ipdb.set_trace()
    for fp in files:
        text = convert(fp, **args.__dict__)
        if args.case_sensitive:
            text = text.lower()
        if args.regex:
            matches = re.finditer(args.query, text, re.MULTILINE)
            for match in matches:
                pass
        else:
            text.find
    return 0


if __name__ == '__main__':
    retcode = main()
