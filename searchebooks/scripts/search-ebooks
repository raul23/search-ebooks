#!/usr/bin/env python
import argparse
import os
import re
import shlex
import subprocess
import time
from pathlib import Path

import searchebooks
from pyebooktools.convert_to_txt import convert
from pyebooktools.configs import default_config
from pyebooktools.lib import (
    BLUE, BOLD, GREEN, NC, RED, VIOLET, YELLOW, color_msg as c,
    convert_result_from_shell_cmd)

DEFAULT_EBOOK_FORMATS = ['djvu', 'epub', 'html', 'pdf', 'txt']
CACHE_FOLDER = os.path.expanduser('~/.search_ebooks')
CACHE_SIZE_LIMIT = default_config.cache_size_limit
DJVU_SEARCH_METHOD = 'djvutxt'
EPUB_SEARCH_METHOD = 'zipgrep'
EVICTION_POLICY = default_config.eviction_policy
MSWORD_SEARCH_METHOD = 'textutil'
PDF_SEARCH_METHOD = 'pdftotext'
USE_CACHE = default_config.use_cache


class ArgumentParser(argparse.ArgumentParser):

    def error(self, message):
        # self.print_help(sys.stderr)
        # self.print_usage(sys.stderr)
        print(self.format_usage().splitlines()[0])
        self.exit(2, c(f'\nerror: {message}\n', 'r'))


# Ref.: https://stackoverflow.com/a/32891625/14664104
class MyFormatter(argparse.HelpFormatter):
    """
    Corrected _max_action_length for the indenting of subactions
    """

    def add_argument(self, action):
        if action.help is not argparse.SUPPRESS:

            # find all invocations
            get_invocation = self._format_action_invocation
            invocations = [get_invocation(action)]
            current_indent = self._current_indent
            for subaction in self._iter_indented_subactions(action):
                # compensate for the indent that will be added
                indent_chg = self._current_indent - current_indent
                added_indent = 'x' * indent_chg
                invocations.append(added_indent + get_invocation(subaction))
            # print('inv', invocations)

            # update the maximum item length
            invocation_length = max([len(s) for s in invocations])
            action_length = invocation_length + self._current_indent
            self._action_max_length = max(self._action_max_length,
                                          action_length)

            # add the item to the list
            self._add_item(self._format_action, [action])

    # Ref.: https://stackoverflow.com/a/23941599/14664104
    def _format_action_invocation(self, action):
        if not action.option_strings:
            metavar, = self._metavar_formatter(action, action.dest)(1)
            return metavar
        else:
            parts = []
            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            # change to
            #    -s, --long ARGS
            else:
                default = action.dest.upper()
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    # parts.append('%s %s' % (option_string, args_string))
                    parts.append('%s' % option_string)
                parts[-1] += ' %s'%args_string
            return ', '.join(parts)


def check_formats():
    class CheckFromats(argparse.Action):
        def __call__(self, parser, args, values, option_string=None):
            for i, v in enumerate(values):
                if v.startswith('.'):
                    v = v[1:]
                    values[i] = v
                if v not in DEFAULT_EBOOK_FORMATS:
                    msg = f'argument "{self.dest}" doesn\'t support {v}. Only ' \
                          'the following ebook formats are supported: ' \
                          f'{DEFAULT_EBOOK_FORMATS}'
                    raise argparse.ArgumentTypeError(msg)
            setattr(args, self.dest, values)
    return CheckFromats


def get_default_message(default_value):
    return f' ({GREEN}default: {default_value}{NC})'


def setup_argparser():
    width = os.get_terminal_size().columns - 5
    # Setup the parser
    name_input = 'input_data'
    msg = 'Search through content and metadata of ebooks.'
    parser = ArgumentParser(
        description=f'{RED}IMPORTANT{NC}: if an argument has spaces, enclose it in '
                    'quotation marks, e.g. "Book title with spaces"',
        usage=f'{BLUE}%(prog)s [OPTIONS] {name_input}{NC}\n\n{msg}',
        add_help=False,
        # ArgumentDefaultsHelpFormatter
        # HelpFormatter
        # RawDescriptionHelpFormatter
        formatter_class=lambda prog: MyFormatter(
            prog, max_help_position=50, width=width))
    general_group = parser.add_argument_group(
        title=f'{YELLOW}General options{NC}')
    general_group.add_argument(
        '-h', '--help', action='help',
        help='Show this help message and exit.')
    general_group.add_argument(
        '-v', '--version', action='version',
        version=f'%(prog)s v{searchebooks.__version__}',
        help="Show program's version number and exit.")
    general_group.add_argument(
        '-q', '--quiet', action='store_true',
        help='Enable quiet mode, i.e. nothing will be printed.')
    general_group.add_argument(
        '--verbose', action='store_true',
        help='Print various debugging information, e.g. print traceback '
             'when there is an exception.')
    general_group.add_argument(
        '-c', '--case-sensitive', action='store_true',
        help='Case sensitive')
    # =====
    # Cache
    # =====
    cache_group = parser.add_argument_group(title=f'{YELLOW}Cache options{NC}')
    cache_group.add_argument(
        '--use-cache', action='store_true', help='Use cache')
    cache_group.add_argument(
        '--cache-folder', default=CACHE_FOLDER, help='Cache folder')
    cache_group.add_argument(
        '--ep', '--eviction-policy', dest='eviction_policy', metavar='POLICY',
        choices=['least-recently-stored', 'least-recently-used',
                 'least-frequently-used', 'none'], default=EVICTION_POLICY,
        help='Eviction policy which can either be: `least-recently-stored`, '
             '`least-recently-used`,  `least-frequently-used` or '
             '`none` (never evict keys).' + get_default_message(EVICTION_POLICY))
    cache_group.add_argument(
        '--csl', '--cache-size-limit', metavar='SIZE', dest='cache_size_limit',
        default=CACHE_SIZE_LIMIT, type=int,
        help='Size limit in gigabytes (GB)'
             + get_default_message(CACHE_SIZE_LIMIT))
    cache_group.add_argument(
        '--cc', '--clear-cache', action='store_true', help='Clear cache')
    # ===========
    # Search text
    # ===========
    search_text_group = parser.add_argument_group(
        title=f'{YELLOW}Search options{NC}')
    search_text_group.add_argument(
        '--query', dest='search_query', metavar='QUERY', required=True,
        help='Search query')
    search_text_group.add_argument(
        '-f', '--ebook-formats', metavar='FORMAT', nargs='+',
        default=DEFAULT_EBOOK_FORMATS, action=check_formats(),
        help=f'{GREEN}Default{NC} ebook formats: '
             f'{GREEN}{DEFAULT_EBOOK_FORMATS}{NC}')
    djvu_search_methods = ['djvutxt', 'calibre']
    search_text_group.add_argument(
        '--dsm', '--djvu-search-method', metavar='METHOD',
        dest='djvu_search_method', choices=djvu_search_methods,
        default=DJVU_SEARCH_METHOD,
        help=f'Search method for djvu files: {djvu_search_methods}'
             + get_default_message(DJVU_SEARCH_METHOD))
    msword_search_methods = ['catdoc', 'textutil', 'calibre']
    search_text_group.add_argument(
        '--msm', '--msword-search-method', metavar='METHOD',
        dest='msword_search_method', choices=msword_search_methods,
        default=MSWORD_SEARCH_METHOD,
        help=f'Search method for doc files: {msword_search_methods}'
             + get_default_message(MSWORD_SEARCH_METHOD))
    epub_search_methods = ['zipgrep', 'calibre']
    search_text_group.add_argument(
        '--esm', '--epub-search-method', metavar='METHOD',
        dest='epub_search_method', choices=['zipgrep', 'calibre'],
        default=EPUB_SEARCH_METHOD,
        help=f'Search method for epub files: {epub_search_methods}'
             + get_default_message(EPUB_SEARCH_METHOD))
    pdf_search_methods = ['pdftotext', 'calibre']
    search_text_group.add_argument(
        '--psm', '--pdf-search-method', metavar='METHOD',
        dest='pdf_search_method', choices=pdf_search_methods,
        default='pdftotext',
        help=f'Search method for pdf files: {PDF_SEARCH_METHOD}'
             + get_default_message(PDF_SEARCH_METHOD))
    # ===============
    # Search metadata
    # ===============
    search_metadata_group = parser.add_argument_group(
        title=f'{YELLOW}Advanced search options{NC}',
        description=f'{RED}IMPORTANT:{NC} all the selected fields are linked '
                    'with AND along with the search query')
    search_metadata_group.add_argument(
        '-a', '--authors', help='Authors')
    search_metadata_group.add_argument(
        '-k', '--book-producer', help='Book producer')
    search_metadata_group.add_argument(
        '--category', help='Category')
    search_metadata_group.add_argument(
        '--comments', help='Comments')
    search_metadata_group.add_argument(
        '-d', '--date', help='Published date')
    search_metadata_group.add_argument(
        '--identifiers', help='Identifiers')
    search_metadata_group.add_argument(
        '-i', '--isbn', help='ISBN')
    search_metadata_group.add_argument(
        '-l', '--language', help='Language')
    search_metadata_group.add_argument(
        '-p', '--publisher', help='Publisher')
    search_metadata_group.add_argument(
        '--rating', help='Rating')
    search_metadata_group.add_argument(
        '-s', '--series', help='Series')
    search_metadata_group.add_argument(
        '--tags', help='Tags')
    search_metadata_group.add_argument(
        '-t', '--title', help='Title')
    # ==============
    # Input argument
    # ==============
    input_group = parser.add_argument_group(title=f'{YELLOW}Input argument{NC}')
    input_group.add_argument(
        name_input,
        help='Can either be the path to an ebook or a folder containing ebooks')
    return parser


def process_file(file_path, args):
    num_matches = 0
    window_length = 200
    ext = file_path.suffix.split('.')[-1]
    if ext not in args.ebook_formats:
        return 1
    flags = re.MULTILINE if args.case_sensitive else re.MULTILINE | re.IGNORECASE
    search_result = {'filename': file_path.name, 'folder_path': file_path.parent,
                     'file_path': file_path, 'matches': []}
    if ext == 'epub' and args.epub_search_method == 'zipgrep':
        zipgrep = 'zipgrep' if args.case_sensitive else 'zipgrep -i'
        cmd = f'find "{file_path}" -exec {zipgrep} {args.search_query} {{}} \\;'
        cmd_args = shlex.split(cmd)
        result = subprocess.run(cmd_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.stderr:
            return 1
        else:
            text = result.stdout.decode()
            # TODO: important, explain remove lines with content.opf
            lines = [l for l in text.splitlines() if not l.count('content.opf')]
            text = '\n'.join(lines)
            matches = re.findall(args.search_query, text, flags)
            # TODO: important, uncomment for interactive
            # text = re.sub(f"({args.search_query})", f"{GREEN}{BOLD}\\1{NC}", text, flags=flags)
            search_result['matches'] = len(matches)
            return search_result
    text = convert(file_path, **args.__dict__)
    if text == 1:
        return 1
    matches = re.findall(args.search_query, text, flags)
    search_result['matches'] = len(matches)
    # TODO: important, uncomment for interactive
    """
    matches = re.finditer(args.search_query, text, flags)
    for match in matches:
        num_matches += 1
        start, end = match.span()
        length = end - start
        if start < window_length / 2:
            subtext = text[start - 0:int(start + length + window_length / 2)]
        else:
            subtext = text[int(start - window_length / 2):int(start + length + window_length / 2)]
        subtext = re.sub(f"({args.search_query})", f"{GREEN}{BOLD}\\1{NC}",
                         subtext, flags=flags)
        # TODO: important, use trans
        subtext = subtext.replace('\n', ' ').replace('\x0cix', '').strip()
        search_result['matches'].append(subtext)
    search_result['matches'] = num_matches
    """
    return search_result


def main():
    parser = setup_argparser()
    args = parser.parse_args()
    # TODO: check if can be done before
    args.cache_size_limit *= 10**9
    search_results = []
    num_results = 0
    total_seconds = 0
    input_data = Path(args.input_data)

    def process_result(start_t, num_res, total_secs):
        if search_result != 1:
            search_results.append(search_result)
            # num_res += len(search_result['matches'])
            num_res += search_result['matches']
        total_secs += time.time() - start_t
        return num_res, total_secs

    if input_data.is_file():
        start_time = time.time()
        search_result = process_file(input_data, args)
        num_results, total_seconds = process_result(start_time, num_results,
                                                    total_seconds)
    else:
        for fp in input_data.rglob('*'):
            print(fp)
            start_time = time.time()
            search_result = process_file(fp, args)
            num_results, total_seconds = process_result(start_time, num_results,
                                                        total_seconds)
        # search_results = sorted(search_results, key=lambda k: len(k['matches']),
        #                         reverse=True)
        search_results = sorted(search_results, key=lambda k: k['matches'],
                                reverse=True)
    print(f'{YELLOW}Total of {num_results} matches ({round(total_seconds, 3)} '
          f'seconds){NC}\n')
    for i, result in enumerate(search_results, start=1):
        print(f"{i}.\t{BLUE}{result['filename']}{NC}"
              f"\n\t{VIOLET}Folder path:{NC} {result['folder_path']}"
              f"\n\t{VIOLET}Number of matches:{NC} {result['matches']}\n")
    # f"\n\t{VIOLET}Number of matches:{NC} {len(result['matches'])}\n")
    return 0


if __name__ == '__main__':
    # search-ebooks ~/test/_search_ebooks/search_text/... --use-cache
    retcode = main()
